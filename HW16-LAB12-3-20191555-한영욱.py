#HW16-LAB12-3-20191555-한영욱
#아래 find gkatnsms current에서 출발하여 방문한적이 없는 노드들을 거쳐
#노드 0으로 돌아가는 최단 경로를 찾아주는 코드이다
w=[[0,2,9,20202020],[1,0,6,4],[20202020,7,0,8],[6,3,20202020,0]]
#이 리스트는 w[여기번호에서 출발해서][여기번호까지] 오는데 걸리는 거리를 나타낸 리스트
#예를 들어 w[0][1]은 0번 자리에서 1번자리까지 가는데 걸리는 거리를 의미한다.
n=4
#여기서 n이 의미하는 바는 들러야 하는 지점의 갯수이다. 
D=[[0]*(1<<n) for _ in range(n)]
#<<은 쉬프트를 의미한다. 만약 3<<1이면 3을 이진수로 나타내어 11로 나태내고 그걸 1만큼 미는 것이다. 그렇게 하면 110이 되고 이는 십진수로 나태내면 6이 된다. 
#고로 여기서 n은 4이고 1<<n은 1<<4와 같기 때문에 1<<n= 1*(2^4)이다.
#즉 이 문장은 리스트 D를 0이 16개 들어있는 리스트가 4개 들어있는 리스트로 만들어라 라는 뜻이 된다.
#여기서 이 D 라는 리스트가 의미하는 바는 n번째 리스트에 자리에 갔을 때 내가 이 숫자에 해당하는 곳들을 방문한 상태라면 목적 달성을 위한 최소 거리를 입력하는 공간이 된 것이다. 
def find(s,v):
    if v==total:#만약 모든 곳을 방문한 상태라면 현재 위치인 s에서 시작 점으로 돌아가는 함수 값을 출력하라.
        return w[s][0] if w[s][0]>0 else 20202020
    if D[s][v]>0:#만약 전에도 이런 적이 있었다면 그 때 경우를 출력하라
        return D[s][v]

    cost=20202020#여기서 cost는 최소 이동 거리인데 무한으로 임시로 표기한다.

    for i in range (1,n):#0으로 돌아가지 않는 경우의 수를 전부 계산 한다.
        if (v>>i)%2==1 or w[s][i]==20202020:continue#만약 그 자리로 가는 길이 없거나 그 자리에 방문한 기록이 있다면 그냥 넘어가라
           
        tmp=find(i,v|(1<<i))#가는 길이 있다면 그 자리로 가고 거기서 0까지 가는 최소 경로를 찾아라

        cost=min(tmp+w[s][i],cost)#지금까지 행한 것들 중 길이 있다면 지금까지 지나온 거리와 그 경로를 더 해보고 다른 길들이랑 비교해서 제일 짧은 것을 기록해라
    D[s][v]=cost#미리 만들어둔 리스트에 그것을 기록해라
    return cost#지금까지 계산한 제일 짧은 거리를 축력해라 

total=(1<<n)-1

r=find(0,1)

print('최적의 cost=%d'%r)
